
%\VignetteIndexEntry{matter: 3D MSI examples with Cardinal}
%\VignetteKeyword{Infrastructure, ImagingMassSpectrometry}

\documentclass[a4paper]{article}
\usepackage{caption}
\usepackage{subcaption}


<<eval=TRUE, echo=FALSE, results=tex>>=
BiocStyle::latex()
@

\title{\Rpackage{matter}: 3D MSI examples with Cardinal}

\author{Kylie A. Bemis}

\begin{document}
\SweaveOpts{concordance=TRUE}

\maketitle

\tableofcontents

\section{Introduction}

This vignette demonstrates the usefulness of \Rpackage{matter} for working with large mass spectrometry imaging (MSI) experiments in \Rpackage{Cardinal}. For versions >=1.5, \Rpackage{Cardinal} supports using \Rpackage{matter} matrices to access larger-than-memory MSI datasets.


\section{Attaching larger-than-memory MS imaging datasets}

This example will use one of the benchmark 3D MSI experiments from Oetjen {\it et al.} \cite{Oetjen:2015en}. We will use the 3D mouse pancreas dataset, which is comprised of 29 tissue sections, with a total of 497,227 pixels and 13,297 features. The data is stored in imzML format \cite{Schramm}. The ".imzML" XML file with experimental metadata is 857.7 MB, and the ".ibd" binary file with the m/z values and spectral intensities is 26.45 GB.

Due to the various offsets in imzML ibd files, they cannot be attached as simply as \Rpackage{bigmemory} or \Rpackage{ff} files. These packages have strict requirements on the format of their data, for maximum computational effiency. \Rpackage{matter} takes a different approach with more flexibility, which allows use of imzML's domain-specific binary file format directly, and with minimal memory footprint, at the cost potentially slower computational performance in some situations.

<<setup-pancreas>>=
library(matter)
library(Cardinal)
path <- "~/Documents/Datasets/MALDI-Imaging/3D_Mouse_Pancreas/"
file <- "3D_Mouse_Pancreas.imzML"
@

<<echo=FALSE,results=hide>>=
options(width=72)
options(Cardinal.verbose=FALSE)
options(Cardinal.progress=FALSE)
par(mar=c(1,0,2,0), bty='n', xaxt='n', yaxt='n')
@

We load the dataset with \Robject{readMSIData} with \Robject{attach.only} set to TRUE. In older versions of \Rpackage{Cardinal} (<1.5), this would use a \Robject{Binmat} matrix, which is far less efficient than a \Robject{matter} matrix. For newer versions of \Rpackage{Cardinal} (>=1.5), if \Rpackage{matter} is in the search path, then \Rpackage{Cardinal} will use a \Robject{matter} matrix.

<<attach-data>>=
mouse <- readMSIData(paste0(path, file), attach.only=TRUE)
mouse
dims(mouse)
dim(mouse)
@

On a 2012 retina MacBook Pro with 2.6 GHz Intel CPU, 16 GB RAM, and 500 GB SSD, parsing the imzML file and attaching the dataset takes approximately 5 minutes and uses roughly 3.6 GB of memory. This is entirely from parsing the 857.7 MB imzML file. \Rpackage{Cardinal} relies on an XML library which requires building a full representation of the XML file in memory, in addition to other memory overhead.

<<echo=FALSE,results=hide>>=
gc()
@

<<idata>>=
iData(mouse)
@

As shown above, the matrix metadata takes up approximately 1.4 GB in memory, and points to 26.4 GB on disk.

Some \Rpackage{Cardinal} methods can be used normally, such as \Robject{pixelApply} and \Robject{featureApply}. Note that it is advisable to \textit{avoid} using \Robject{featureApply} for large on-disk datasets, because it will be extremely efficient. Because imzML ibd files store spectra contiguously, rather than images, loading images requires many non-contiguous reads, which take much longer than reading contiguous mass spectra.

Nonetheless, we can, for example, use \Robject{pixelApply} to calculate the total ion current (TIC) for each pixel.

<<tic>>=
mouse.tic <- pixelApply(mouse, sum)
summary(mouse.tic)
@

On the same MacBook Pro, computing the TIC for every pixel takes approximately 4 minutes and uses about 500 MB of additional memory.

We will plot an image of the TIC later.

\section{Plotting 3D ion images}

3D molecular ion images can be plotted using the \Robject{image3D} method introduced in \Rpackage{Cardinal} v1.3.2. We will plot the ion image for $m/z$ 5806, which corresponds to insulin.

<<ion-image>>=
image3D(mouse, mz=5806, plusminus=1, phi=45, theta=180)
@

Loading the ion image from file and plotting it takes approximately 2 minutes on the same MacBook Pro and uses an additional 2 GB of memory in overhead. The max amount of memory used while plotting the image was just under 3 GB, for the 26.4 GB dataset.

<<tic-image>>=
image3D(mouse, mouse.tic ~ x * y * z, phi=45, theta=180)
@

Lastly, we will plot TIC of each pixel, which we calculated earlier using \Robject{pixelApply} above.

\setkeys{Gin}{width=\textwidth}
\begin{figure}[h]
\centering
\begin{subfigure}{.3\textwidth}
  \centering
<<fig=TRUE, echo=FALSE, results=hide>>=
<<ion-image>>
@
\caption{\small $m/z$ 5806 (insulin)}
\label{fig:mz5806}
\end{subfigure}
\begin{subfigure}{.3\textwidth}
  \centering
<<fig=TRUE, echo=FALSE, results=hide>>=
<<tic-image>>
@
\caption{\small TIC (total ion current)}
\label{fig:3dimage}
\end{subfigure}
\caption{\small Plotting 3D images of the benchmark 3D mouse pancreas dataset.}
\end{figure}

\section{Principal componenets analysis of large 3D MS images}

Now we will demonstrate principal components analysis (PCA) with one of the benchmark 3D MSI experiments from Oetjen {\it et al.} \cite{Oetjen:2015en}. PCA is a common unsupervised multivariate technique used to summarize and visualize the majority of the variation in the dataset.

We will use the 3D microbial timecourse experiment, which is comprised of interacting microbes at 3 time points, with a total of 17,672 pixels and 40,299 features. The data is stored in imzML format \cite{Schramm}. The ".imzML" XML file with experimental metadata is 30.5, and the ".ibd" binary file with the m/z values and spectral intensities is 2.85 GB.

<<setup-microbe>>=
path <- "~/Documents/Datasets/MALDI-Imaging/3D_Timecourse/"
file <- "Microbe_Interaction_3D_Timecourse_LP.imzML"
microbe <- readMSIData(paste0(path, file), attach.only=TRUE)
iData(microbe)
dims(microbe)
dim(microbe)
@

The dataset was stored so that the first time point $t = 4$ corresponds to $z = {1,2,3,4,5,6}$, the second time point $t = 8$ corresponds to $z = {7,8,9,10,11,12}$, and the third time point $t = 11$ corresponds to $z = {13,14,15,16,17,18}$. We will reparamaterize the coordinates below to make it easier to work with the dataset. We also remove duplicated coordinates caused by converting the z-dimension to sequential integers.

<<>>=
microbe <- microbe[,!duplicated(coord(microbe))]

microbe$sample <- factor(sapply(microbe$z, function(z) {
	if ( z %in% 1:6 ) {
		1
	} else if ( z %in% 7:12 ) {
		2
	} else if ( z %in% 13:18 )  {
		3
	}
}), labels=c("t = 4", "t = 8", "t = 11"))

microbe$z <- sapply(microbe$z, function(z) {
	if ( z %in% 1:6 ) {
		z
	} else if ( z %in% 7:12 ) {
		z-6
	} else if ( z %in% 13:18 )  {
		z-12
	}
})

microbe$x <- mapply(function(x, t) {
	switch(as.integer(t),
		x-30,
		x-15,
		x)
}, microbe$x, microbe$sample)

varMetadata(microbe)[c("x","y","z","sample"),"labelType"] <- "dim"

protocolData(microbe) <- AnnotatedDataFrame(
	data=data.frame(row.names=sampleNames(microbe)))

microbe <- regeneratePositions(microbe)

validObject(microbe)
@

We can now plot the molecular ion image for $m/z$ 262.

<<microbe-ion>>=
image3D(microbe, ~ x * z * y, mz=262, theta=-55, contrast="suppress", layout=c(3,1))
@

Now we perform principal components analysis.

% <<microbe-pca-offline>>=
% matter:::profile({
% 	microbe.pca <- PCA(microbe, ncomp=3, method="irlba", center=TRUE)
% 	pData(microbe)[,c("PC1","PC2","PC3")] <- microbe.pca$scores[["ncomp = 3"]]
% 	fData(microbe)[,c("PC1","PC2","PC3")] <- microbe.pca$loadings[["ncomp = 3"]]
% })
%   # start (MB)   finish (MB) max used (MB) overhead (MB)    time (sec) 
%   #    146.300       148.500       203.300        54.800      1900.234 
%   #     146.600       146.600       203.200        56.600      1931.998 
%      # 144.100       148.000       204.000        56.000      2154.024 
%       # 144.10        148.00        204.90         56.90       2091.53
%     # 144.100       148.000       204.900        56.900      2066.895 

% figpath <- "~/Documents/Northeastern/Papers/Bioinformatics-matter/figs/"

% save(microbe.pca, file=paste0(figpath, "microbe-pca.RData"))

% pdf(paste0(figpath, "microbe-ion-img.pdf"), height=3, width=4)
% image3D(microbe, ~ x * z * y, mz=262, theta=-55, contrast="suppress", layout=c(3,1))
% dev.off()

% pdf(paste0(figpath, "microbe-pc1-img.pdf"), height=3, width=4)
% image3D(microbe, PC1 ~ x * z * y, theta=-55, col.regions=risk.colors(100), layout=c(3,1))
% dev.off()

% pdf(paste0(figpath, "microbe-pc2-img.pdf"), height=3, width=4)
% image3D(microbe, PC2 ~ x * z * y, theta=-55, col.regions=risk.colors(100), layout=c(3,1))
% dev.off()
% @

<<microbe-pca>>=
microbe.pca <- PCA(microbe, ncomp=3, method="irlba", center=TRUE)
pData(microbe)[,c("PC1","PC2","PC3")] <- microbe.pca$scores[["ncomp = 3"]]
fData(microbe)[,c("PC1","PC2","PC3")] <- microbe.pca$loadings[["ncomp = 3"]]
@

<<microbe-pc1-img>>=
image3D(microbe, PC1 ~ x * z * y, theta=-55, col.regions=risk.colors(100), layout=c(3,1))
@

<<microbe-pc2-img>>=
image3D(microbe, PC2 ~ x * z * y, theta=-55, col.regions=risk.colors(100), layout=c(3,1))
@

<<microbe-pc3-img>>=
image3D(microbe, PC3 ~ x * z * y, theta=-55, col.regions=risk.colors(100), layout=c(3,1))
@

\setkeys{Gin}{width=\textwidth}
\begin{figure}[h]
\centering
\begin{subfigure}{.2\textwidth}
  \centering
<<fig=TRUE, echo=FALSE, results=hide>>=
<<microbe-pc1-img>>
@
\caption{\small PC1 scores}
\label{fig:pc1}
\end{subfigure}
\begin{subfigure}{.2\textwidth}
  \centering
<<fig=TRUE, echo=FALSE, results=hide>>=
<<microbe-pc2-img>>
@
\caption{\small PC2 scores}
\label{fig:pc2}
\end{subfigure}
\begin{subfigure}{.2\textwidth}
  \centering
<<fig=TRUE, echo=FALSE, results=hide>>=
<<microbe-pc3-img>>
@
\caption{\small PC3 scores}
\label{fig:pc3}
\end{subfigure}
\caption{\small Plotting the first 3 principal components for the 3D microbial time course experiment.}
\end{figure}

On the same 2012 retina MacBook Pro with 2.6 GHz Intel CPU, fitting the first 3 principal components takes approximately 31 minutes (1900 seconds), or about 10 minutes (633 seconds) per component. The data is implicitly centered during the calculation without changing any data on disk. The calculation used 53 MB of memory in overhead, and the maximum amount of memory used during the entire calculation was only 199 MB for the 2.85 GB dataset.


\section{Session info}

<<results=tex, echo=FALSE>>=
toLatex(sessionInfo())
@

% \bibliographystyle{unsrt}
\bibliography{matter-extra}

\end{document}
